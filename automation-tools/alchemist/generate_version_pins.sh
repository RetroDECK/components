#!/bin/bash

# ==============================================================================
#  VERSION PINS GENERATOR
#  ----------------
#  Generates a version_pins.sh file from components_metadata.json.
#
#  Usage:
#    generate_version_pins.sh -m <metadata_json> [-o <output_file>]
#
#  The metadata JSON is expected in the format produced by the components
#  build workflow's "Resolve component versions" step:
#
#    {
#      "component-name": {
#        "version": "<resolved version string>",
#        "git_tree_hash": "<hash>",
#        "built_on": "<timestamp>"
#      },
#      ...
#    }
#
#  If no output file is specified, defaults to version_pins.sh in the
#  same directory as the metadata file.
# ==============================================================================

set -euo pipefail

log() {
  echo "[$1] $2" >&2
}

generate_pins() {
  local metadata_file="$1"
  local output_file="$2"
  local pin_count=0
  local skip_count=0

  if [[ ! -f "$metadata_file" ]]; then
    log error "Metadata file not found: $metadata_file"
    return 1
  fi

  # Validate JSON
  if ! jq empty "$metadata_file" 2>/dev/null; then
    log error "Invalid JSON in metadata file: $metadata_file"
    return 1
  fi

  {
    echo "#!/bin/bash"
    echo ""
    echo "# =============================================================================="
    echo "#  VERSION PINS (auto-generated)"
    echo "#  ----------------"
    echo "#  Generated: $(date -u +%Y-%m-%d\ %H:%M:%S\ UTC)"
    echo "#  Source:    $metadata_file"
    echo "#"
    echo "#  These pinned versions override the resolution policies in version_policy.sh."
    echo "#  Do not edit manually - this file is generated by generate_version_pins.sh"
    echo "#  from the resolved component versions of a successful build."
    echo "# =============================================================================="
    echo ""

    while IFS= read -r component; do
      local version
      version=$(jq -r --arg c "$component" '.[$c].version // empty' "$metadata_file")

      if [[ -z "$version" ]]; then
        log warn "No version found for component '$component', skipping"
        ((skip_count++))
        continue
      fi

      # Skip components whose version is still a placeholder
      if [[ "$version" =~ ^(latest|newest)(\ on\ .*)?$ ]]; then
        log warn "Component '$component' resolved to placeholder '$version', skipping pin"
        ((skip_count++))
        continue
      fi

      # Normalize component name to match *_VERSION_POLICY convention:
      #   component-name -> COMPONENT_NAME_PINNED_VERSION
      local normalized
      normalized="${component//-/_}"
      normalized="${normalized^^}"

      echo "export ${normalized}_PINNED_VERSION=\"${version}\""
      ((pin_count++))

    done < <(jq -r 'keys[]' "$metadata_file")

  } > "$output_file"

  log info "Generated $output_file: $pin_count pinned, $skip_count skipped"
}

parse_args() {
  local metadata_file=""
  local output_file=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -m|--metadata)
        metadata_file="$2"
        shift 2
        ;;
      -o|--output)
        output_file="$2"
        shift 2
        ;;
      *)
        echo "Unknown option: $1" >&2
        echo "Usage: $0 -m <metadata_json> [-o <output_file>]" >&2
        return 1
        ;;
    esac
  done

  if [[ -z "$metadata_file" ]]; then
    log error "Missing required argument: -m <metadata_json>"
    echo "Usage: $0 -m <metadata_json> [-o <output_file>]" >&2
    return 1
  fi

  # Default output to same directory as metadata
  if [[ -z "$output_file" ]]; then
    output_file="$(dirname "$metadata_file")/version_pins.sh"
  fi

  generate_pins "$metadata_file" "$output_file"
}

parse_args "$@"
